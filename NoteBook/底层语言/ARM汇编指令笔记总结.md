# ARM汇编指令笔记总结



## 标记符号

| 符号 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| !    | 若选用该后缀，则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变 |
| %    | 二进制数                                                     |
| ^    | 当指令为LDM且寄存器列表中包含R15，选用该后缀时表示：除了正常的数据传送之外，还将SPSR复制到CPSR<br />同时，该后缀还表示传入或传出的是用户模式下的寄存器，而不是当前模式下的寄存器 |





## CPRS条件码标志位

| [31] N  | [30] Z | [29] C         | [28] V |
| ------- | ------ | -------------- | ------ |
| 负/小于 | 零     | 进位/借位/扩展 | 溢出   |





## 数据传送指令

### MOV

>   数据传送指令，它的传送指令只能是把一个寄存器的值(要能用立即数表示)赋给另一个寄存器，或者将一个常量赋给寄存器，将后边的量赋给前边的量
>
>   MOV指令的格式为：MOV{条件}{S}  目的寄存器,  源操作数

MOV指令中，条件缺省时指令无条件执行；S选项决定指令的操作是否影响CPSR中条件标志位的值，当没有S时指令不更新CPSR中条件标志位的值

**指令示例：**

```
MOV R1, R0  ; 将寄存器R0的值传送到寄存器R1
MOV PC, R14  ; 将寄存器R14的值传送到PC，常用于子程序返回
MOV R1, R0, LSL#3  ; 将寄存器R0的值左移3位后传送到R1（即乘8）
MOVS PC, R14  ; 将寄存器R14的值传送到PC中，返回到调用代码并恢复标志位
```



### MVN

>   数据取反传送指令，可完成从另一个寄存器、被移位的寄存器、或将一个立即数加载到目的寄存器
>
>   MVN指令的格式为：MVN{条件}{S}  目的寄存器,  源操作数

与MOV指令不同之处是在传送之前按位被取反了，即把一个被取反的值传送到目的寄存器中。其中S决定指令的操作是否影响CPSR中条件标志位的值，当没有S时指令不更新CPSR中条件标志位的值

**指令示例：**

```
MVN R0, #0  ; 将立即数0取反传送到寄存器R0中，完成后R0=-1（有符号位取反）
```





## 算数运算指令

### ADD

>   加法指令。ADD指令用于把两个操作数相加，并将结果存放到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数
>
>   ADD指令的格式为：ADD{条件}{S}  目的寄存器,  操作数1,  操作数2

**指令示例：**

```
ADD R0, R1, R2  ; R0 = R1 + R2
ADD R0, R1, #256  ; R0 = R1 + 256
ADD R0, R2, R3, LSL#1  ; R0 = R2 + (R3 << 1)
```



### ADC

>   带进位的加法指令。ADC指令用于把两个操作数相加，再加上CPSR中的C条件标志位的值，并将结果存放到目的寄存器中，它使用一个进位标志位，这样就可以做比32位大的数的加法，注意不要忘记设置S后缀来更改进位标志
>
>   xx指令的格式为：ADC{条件}{S}  目的寄存器,  操作数1,  操作数2

**指令示例：**

```
ADDS R0, R4, R8  ； 加低端的字，R0=R4+R8
ADCS R1, R5, R9  ； 加第二个字，带进位,R1=R5+R9
ADCS R2, R6, R10  ； 加第三个字，带进位,R2=R6+R10
ADC R3, R7, R11  ； 加第四个字，带进位,R3=R7+R11
```



### SUB

>   减法指令，用于把操作数1减去操作数2，并将结果存放到目的寄存器中
>
>   SUB指令的格式为：SUB{条件}{S}  目的寄存器,  操作数1,  操作数2

**指令示例：**

```
SUB R0, R1, R2  ; R0 = R1 - R2
SUB R0, R1, #256  ; R0 = R1 - 256
SUB R0, R2, R3，LSL#1  ; R0 = R2 - (R3 << 1)
```



### SBC

>   带借位减法指令，用于把操作数1减去操作数2，再减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器中
>
>   SBC指令的格式为：SBC{条件}{S}  目的寄存器,  作数1,  操作数2

**指令示例：**

```
SUBS R0, R1, R2  ; R0 = R1 - R2 - !C，并根据结果设置CPSR的进位标志位
```



### CMP

>   比较指令，用于把一个寄存器的内容和另一个寄存器的内容或立即数**进行减法比较**，同时更新CPSR中条件标志位的值
>
>   CMP指令的格式为：CMP{条件}  操作数1,  操作数2

**指令示例：**

```
CMP R1, R0  ; 将寄存器R1的值与寄存器R0的值相减，并根据结果设置CPSR的标志位
CMP R1, ＃100  ; 将寄存器R1的值与立即数100相减，并根据结果设置CPSR的标志位
```

该指令进行一次减法运算，但不存储结果，只更改条件标志位。标志位表示的是操作数1与操作数2的关系(大、小、相等)，例如，当操作数1大于操作操作数2，则此后的有GT后缀的指令将可以执行。

对照普通的减法指令 SUB AX, BX，它们的区别就在于：

-   SUB指令执行过以后，原来AX中的被减数丢了，被换成了减法的结果。
-   CMP指令执行过以后，被减数、减数都保持原样不变。



### CMN

>   负数比较指令，用于把一个寄存器的内容和另一个寄存器的内容或立即数取反后进行比较，同时更新CPSR中条件标志位的值
>
>   CMN指令的格式为：CMN{条件}  操作数1,  操作数2

该指令实际完成操作数1和操作数2相加，并根据结果更改条件标志位

**指令示例：**

```
CMN R1, R0  ; 将寄存器R1的值与寄存器R0的值相加，并根据结果设置CPSR的标志位
CMN R1, #100  ; 将寄存器R1的值与立即数100相加，并根据结果设置CPSR的标志位
```





## 逻辑处理指令

### AND

>   逻辑与指令，用于在两个操作数上进行逻辑与运算，并把结果放置到目的寄存器中
>
>   AND指令的格式为：AND{条件}{S}  目的寄存器,  操作数1,  操作数2

该指令常用于屏蔽操作数1的某些位

**指令示例：**

```
AND R0, R0, #3  ; 该指令保持R0的0、1位，其余位清零
```



### ORR

>   逻辑或指令，用于在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中
>
>   ORR指令的格式为：ORR{条件}{S}  目的寄存器,  操作数1,  操作数2

该指令常用于设置操作数1的某些位

**指令示例：**

```
ORR R0, R0, #3  ; 该指令设置R0的0、1位，其余位保持不变
```



### EOR

>   逻辑异或指令，用于在两个操作数上进行逻辑异或运算，并把结果放置到目的寄存器中
>
>   EOR指令的格式为：EOR{条件}{S} 目的寄存器，操作数1，操作数2

该指令常用于反转操作数1的某些位

**指令示例：**

```
EOR R0, R0, #3  ; 该指令反转R0的0、1位，其余位保持不变
```



### BIC

>   位清零指令，用于清除操作数1的某些位，并把结果放置到目的寄存器中
>
>   BIC指令的格式为：BIC{条件}{S}  目的寄存器,  操作数1,  操作数2

操作数2为32位的掩码，如果在掩码中设置了某一位，则清除这一位。未设置的掩码位保持不变

**指令示例：**

```
BIC R0, R0, #%1011  ; 该指令清除 R0 中的位 0、1、和 3，其余的位保持不变
```



### TST

>   位测试指令，用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位的与运算，并根据运算结果更新CPSR中条件标志位的值
>
>   TST指令的格式为：TST{条件}  操作数1,  操作数2

该指令一般用来检测是否设置了特定的位

**指令示例：**

```
TST R1, #%1  ; 用于测试在寄存器R1中是否设置了最低位（％表示二进制数）
TST R1, #0xffe  ; 将寄存器R1的值与立即数0xffe按位与，并根据结果设置CPSR的标志位
```



### TEQ

>   位测试指令，用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位的异或运算，并根据运算结果更新CPSR中条件标志位的值
>
>   TEQ指令的格式为：TEQ{条件}  操作数1,  操作数2

该指令通常用于比较操作数1和操作数2是否相等

**指令示例：**

```
TEQ R1, R2  ; 将寄存器R1的值与寄存器R2的值按位异或，并根据结果设置CPSR的标志位
```



### BNE & BEQ

>数据跳转指令，标志寄存器中**Z标志位不等于零**时，**跳转到BNE**后标签处；标志寄存器中**Z标志位等于零**时，**跳转到BEQ**后标签处

**指令示例：**

```
TST r0, #0x2  ; 进行and运算，如果bit第二位为1，zero=0；如果bit第二位为0，则zero=1，即该指令测试bit第二位是否为0
BNE led_blink  ; 非零则跳转到led_blink处执行，若zero=0，则继续执行下一步指令
```

```
SUB r1, r1, #1  ; r1=r1-1
CMP r1, #0  ; r1是否等于0，并更改标志位     
BNE led_blink  ; zero=1时跳转至led_blink处，zero=0时则继续执行
```





## 状态寄存器访问指令

### MRS

>   MRS指令用于将程序状态寄存器的内容传送到通用寄存器中
>
>   MRS指令的格式为：MRS{条件}  通用寄存器,  程序状态寄存器（CPSR或SPSR）

该指令一般用在以下几种情况：

-   当需要改变程序状态寄存器的内容时，可用MRS将程序状态寄存器的内容读入通用寄存器，修改后再写回程序状态寄存器
-   当在异常处理或进程切换时，需要保存程序状态寄存器的值，可先用该指令读出程序状态寄存器的值，然后保存

**指令示例：**

```
MRS R0, CPSR  ; 传送CPSR的内容到R0（R0 <- CPSR）
MRS R0, SPSR  ; 传送SPSR的内容到R0
```



### MSR

>   MSR指令用于将操作数的内容传送到程序状态寄存器的特定域中
>
>   MSR指令的格式为：MSR{条件}  程序状态寄存器(CPSR或SPSR)_<域>,  操作数

该指令通常用于恢复或改变程序状态寄存器的内容，在使用时，一般要在MSR指令中指明将要操作的域

其中，操作数可以为通用寄存器或立即数。<域>用于设置程序状态寄存器中需要操作的位，32位的程序状态寄存器可分为4个域：

| f                        | s                    | x                   | c                  |
| ------------------------ | -------------------- | ------------------- | ------------------ |
| 位[31：24]为条件标志位域 | 位[23：16]为状态位域 | 位[15：8]为扩展位域 | 位[7：0]为控制位域 |

**指令示例：**

```
MSR CPSR，R0   ；传送R0的内容到CPSR
MSR SPSR，R0   ；传送R0的内容到SPSR
MSR CPSR_c，R0  ；传送R0的内容到SPSR，但仅仅修改CPSR中的控制位域
```





## 存储指令

>   **LDR, STR**是用于寄存器和外部存储器交换数据指令，注意与**MOV**的区别，**MOV**只能在寄存器之间移动数据，或者把立即数移动到寄存器中

### LDR

>   **LDR(load)**用于把一个32Bit的WORD数据从外部存储空间装入到寄存器中
>
>   LDR指令的格式为： LDR{条件}  目的寄存器,  <存储器地址>

**指令示例：**

```
LDR R0, [R1]  ; 将R1的字数据读入寄存器R0(R0<--[R1])
LDR R1, =0x30008000  ; 把地址0x30008000的值装入到R1中,LDR中用常数要用=打头
LDR R0, [R1, R2]  ; 将R1+R2的字数据读入寄存器R0
LDR R0, [R1, ＃8]  ; 将R1+8的字数据读入寄存器R0
LDR R0, [R1, R2]!  ; 将R1+R2的字数据读入寄存器R0,并将新地址R1＋R2写入R1
LDR R0, [R1, ＃8]!  ; 将R1+8的字数据读入寄存器R0, 并将新地址R1＋8写入R1 
LDR R0, [R1], R2  ; 将存储器地址为R1的字数据读入寄存器R0, 并将新地址R1＋R2写入R1
LDR R0, [R1, R2, LSL＃2]!  ; 将存储器地址为R1＋R2×4的字数据读入寄存器R0, 并将新地址R1＋R2×4写入R1
LDR R0, [R1], R2, LSL＃2  ; 将存储器地址为R1的字数据读入寄存器R0, 并将新地址R1＋R2×4写入R1
```

**伪指令**

>   ARM指令集中，LDR通常都是作加载指令的，但是它也可以作伪指令
>
>   LDR伪指令用于加载32位的立即数或一个地址值到指定寄存器。在汇编编译源程序时，LDR伪指令被编译器替换成一条合适的指令。若加载的常数未超出MOV或MVN的范围，则使用MOV或MVN指令代替该LDR伪指令，否则汇编器将常量放入文字池，并使用一条程序相对偏移的LDR指令从文字池读出常量
>
>   LDR伪指令的形式是：LDR  Rn,  =expr

**指令示例：**

```c
COUNT EQU 0x40003100
LDR R1, =COUNT
```



### STR

>   **STR(Store)** 用于把一个寄存器的值存入外部存储空间,是LDR的逆操作
>
>   STR指令的格式为：STR{条件}  源寄存器,  <存储器地址>

**指令示例：**

```
STR R0, [R1]  ; 把R0的值,存入到R1对应地址空间上(R1-->R0)
STR R0, =0x30008000  ; 把R0中值存入到地址0x30008000
STR R0, [R1],＃8  ; 将R0中的字数据写入以R1为地址的存储器中,并将新地址R1＋8写入R1.
STR R0, [R1,＃8]  ; 将R0中的字数据写入以R1＋8为地址的存储器中。
```



### LDM

>   LDM指令作用于将内存中堆栈内的数据，批量的赋值给寄存器，即是出栈操作
>
>   LDM指令的格式为：LDMFD  SP! ,  {R0, R1, R2} 

**指令示例：**

```
STMFD SP!, {R0-R2}  ; 意思为：把sp指向的3个连续地址段（应该是3*4=12字节（因为为r0,r1,r2都是32位））中的数据拷贝到r0,r1,r2这3个寄存器中去
```

**注意：**其中堆栈指针一般对应于SP，注意SP是寄存器R13，实际用到的却是R13中的内存地址，只是该指令没有写为[R13]，所以指令格式可以理解为：LDMFD  [SP]! ...



### STM

>   与LDM是配对使用的，是入栈操作，区别于STR，堆栈指针写在左边，寄存器组写在右边
>
>   STM指令的格式为：STMFD   SP!,  {R0}；指令也可理解为：STMFD  [SP]!,  {R0}

上述格式的意思是：把R0保存到堆栈（sp指向的地址）中

>   STM和LDM的主要用途是现场保护、数据复制、参数传递等

其模式有8种，如下：（前面4种用于数据块的传输，后面4种用于堆栈操作）

| 模式 | 解释              |
| ---- | ----------------- |
| IA   | 每次传送后地址加4 |
| IB   | 每次传送前地址加4 |
| DA   | 每次传送后地址减4 |
| DB   | 每次传送前地址减4 |

| 模式 | 解释       |
| ---- | ---------- |
| FD   | 满递减堆栈 |
| FA   | 满递增堆栈 |
| ED   | 空递减堆栈 |
| EA   | 空递增堆栈 |

**注意：**ARM编译器默认高寄存器优先存入堆栈，所以`STMDB R0!, {R1-R3}` 和 `STMDB R0!, {R3,R2,R1}`在执行后，堆栈中存储的顺序是一样的





## 位移指令

| 指令 | 作用             |
| ---- | ---------------- |
| LSL  | 逻辑左移         |
| ASL  | 算术左移         |
| LSR  | 逻辑右移         |
| ASR  | 算术右移         |
| ROR  | 循环右移         |
| RRX  | 带扩展的循环右移 |

ASL 和 LSL 是等同的，可以自由互换

可以用一个立即值(从0到31)指定移位数量,或用包含在0和31之间的一个值的寄存器指定移位数量

**指令示例：**

```
MOV R1, R0, LSL#3  ; 将寄存器R0的值左移3位后传送到R1（即乘8）
ADD R0, R2, R3, LSL#1  ; R0 = R2 + (R3 << 1)
```





## 跳转指令

>   跳转指令用于实现程序流程的跳转，在ARM程序中有两种方法可以实现程序流程的跳转：
>
>   -   使用专门的跳转指令
>   -   直接向程序计数器PC写入跳转地址值

### B指令

>   B指令是最简单的跳转指令。一旦遇到一个 B 指令，ARM 处理器将立即跳转到给定的目标地址，从那里继续执行
>
>   B指令的格式为：B{条件}  目标地址

存储在跳转指令中的实际值是相对当前PC值的一个偏移量，而不是一个绝对地址，它的值由汇编器来计算（参考寻址方式中的相对寻址）

**指令示例：**

```
B Label  ; 程序无条件跳转到标号Label处执行
CMP R1, #0  ; 当CPSR寄存器中的Z条件码置位时，程序跳转到标号Label处执行
BEQ Label
```



### BL指令

>   BL是另一个跳转指令，但跳转之前，会在寄存器R14中保存PC的当前内容，因此，可以通过将R14 的内容重新加载到PC中来**继续从跳转之前的代码处运行**
>
>   BL指令的格式为：BL{条件}  目标地址

**指令示例：**

```
BL Label  ; 当程序无条件跳转到标号Label处执行时，同时将当前的PC值保存到R14中
```



### BX指令

>   BX指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM指令，也可以是Thumb指令
>
>   BX指令的格式为：BX{条件}  目标地址



### BLX指令

>   结合BX和BL的特点，跳转到Rm指定的地址，并将返回地址保存在LR中，切换指令集
>
>   BLX指令的格式为：BLX{条件}  目标地址





## GNU汇编

**GNU 汇编语法适用于所有的架构**，并不是 ARM 独享的，GNU 汇编由一系列的语句组成，每行一条语句，每条语句有三个可选部分，如下：

```
label: instruction @comment
```

**label** 即标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。注意 label 后面的`:`，任何以`:`结尾的标识符都会被识别为一个标号。

**instruction** 即指令，也就是汇编指令或伪指令

**@** 符号，表示后面的是注释

**comment** 就是注释内容

比如如下代码：

```
add:
MOVS R0, #0x12  @设置 R0=0x12
```

### 伪操作

| 伪操作  | 含义                                                         |
| ------- | ------------------------------------------------------------ |
| .byte   | 定义单字节数据，比如.byte 0x12                               |
| .short  | 定义双字节数据，比如.short 0x1234                            |
| .long   | 定义一个 4 字节数据，比如.long 0x12345678                    |
| .equ    | 赋值语句，格式为：.equ 变量名，表达式，比如.equ num, 0x12，表示 num=0x12 |
| .align  | 数据字节对齐，比如：.align 4 表示 4 字节对齐                 |
| .end    | 表示源文件结束                                               |
| .global | 定义一个全局符号，格式为：.global symbol，比如：.global _start |
