{
  "folders": [
    {
      "name": "Android",
      "parentId": null,
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "java",
      "id": "1NX5tDl1",
      "createdAt": 1659359284713,
      "updatedAt": 1659367810877
    }
  ],
  "snippets": [
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "1NX5tDl1",
      "tagsIds": [],
      "description": "以单个类的形式存在，类中包含多个方法，可满足某些复杂的需求",
      "name": "工具类",
      "content": [
        {
          "label": "UnCeHandler",
          "language": "java",
          "value": "import android.app.AlarmManager;\r\nimport android.app.Application;\r\nimport android.app.PendingIntent;\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.os.Build;\r\nimport android.util.Log;\r\n\r\n/**\r\n * 捕获程序漏掉的崩溃异常，并重启应用或服务\r\n * <p>\r\n * 在application中使用如下方式调用：\r\n * 重启Activity:\r\n * Thread.setDefaultUncaughtExceptionHandler(new UnCeHandler(this, Activity.class, UnCeHandler.TYPE_ACTIVITY));\r\n * 单独重启Service:\r\n * Thread.setDefaultUncaughtExceptionHandler(new UnCeHandler(this, Service.class, UnCeHandler.TYPE_SERVICE));\r\n */\r\npublic class UnCeHandler implements Thread.UncaughtExceptionHandler {\r\n    public static final String TAG = \"UnCeHandler\";\r\n    public static final int TYPE_ACTIVITY = 0x0;\r\n    public static final int TYPE_SERVICE = 0x1;\r\n\r\n    private static final long DELAY_CLOSE_TIME = 2_000; //延迟杀掉应用的时间\r\n    private static final long REBOOT_TIME = 1_000; //重启应用的时间\r\n    private final Thread.UncaughtExceptionHandler mDefaultHandler;\r\n    private final Application application;\r\n    private final Context mContext;\r\n    private final Class<?> cls;\r\n    private final int selectType;\r\n\r\n\r\n    // ===================== init ============================== //\r\n    public UnCeHandler(Application application, Class<?> cls, int type) {\r\n        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();\r\n        this.application = application;\r\n        this.mContext = application.getApplicationContext();\r\n        this.cls = cls;\r\n        this.selectType = type;\r\n    }\r\n\r\n\r\n    // ===================== Override ============================== //\r\n    @Override\r\n    public void uncaughtException(Thread thread, Throwable ex) {\r\n        if (!handleException(ex) && mDefaultHandler != null) {\r\n            //如果用户没有处理则让系统默认的异常处理器来处理\r\n            mDefaultHandler.uncaughtException(thread, ex);\r\n        } else {\r\n            delayClose(); //延迟指定时间\r\n\r\n            Intent intent = new Intent(mContext, cls);\r\n            PendingIntent restartIntent;\r\n            AlarmManager mgr;\r\n            switch (selectType) {\r\n                //重启service服务\r\n                case TYPE_SERVICE:\r\n                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n                        /**\r\n                         * PendingIntent.getForegroundService(context, requestCode, intent, flags)\r\n                         *\r\n                         * 第一个参数：连接上下文的context\r\n                         * 第二个参数：是对PendingIntent的描述，请求值不同Intent就不同\r\n                         * 第三个参数：是一个Intent对象，包含跳转目标\r\n                         * 第四个参数有4种状态：\r\n                         *      FLAG_CANCEL_CURRENT: 如果有多个requestCode，则使用最新的PendingIntent对象\r\n                         *      FLAG_NO_CREATE: 如果有相同的PendingIntent存在，直接使用，否则返回null，不会自动创建新的\r\n                         *      FLAG_ONE_SHOT: 该PendingIntent只作用一次，触发后会销毁，再次触发会返回SendIntentException\r\n                         *      FLAG_UPDATE_CURRENT: 如果有一个相同的PendingIntent，则更新之前的数据，使旧的和新的数据一致\r\n                         *      常用的为 FLAG_CANCEL_CURRENT 和 FLAG_UPDATE_CURRENT\r\n                         */\r\n                        restartIntent = PendingIntent.getForegroundService(\r\n                                mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\r\n                    } else {\r\n                        restartIntent = PendingIntent.getService(\r\n                                mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\r\n                    }\r\n                    break;\r\n                //重启Activity\r\n                case TYPE_ACTIVITY:\r\n                default:\r\n                    restartIntent = PendingIntent.getActivity(\r\n                            mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\r\n                    break;\r\n            }\r\n            mgr = (AlarmManager) application.getSystemService(Context.ALARM_SERVICE);\r\n            mgr.set(AlarmManager.RTC, System.currentTimeMillis() + REBOOT_TIME, restartIntent);\r\n            android.os.Process.killProcess(android.os.Process.myPid());\r\n        }\r\n    }\r\n\r\n\r\n    // ===================== function ============================== //\r\n\r\n    /**\r\n     * 延迟指定时间关闭\r\n     */\r\n    private void delayClose() {\r\n        if (DELAY_CLOSE_TIME > 0) {\r\n            try {\r\n                Thread.sleep(DELAY_CLOSE_TIME);\r\n            } catch (InterruptedException e) {\r\n                Log.e(TAG, \"error: \", e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 自定义错误处理，收集错误信息 发送错误报告等操作均在此完成\r\n     *\r\n     * @param ex\r\n     * @return true:处理了该异常信息，否则返回false\r\n     */\r\n    private boolean handleException(Throwable ex) {\r\n        if (ex == null) {\r\n            return false;\r\n        }\r\n        //TODO：程序退出前会先运行此函数，可以在此处理异常信息\r\n        // (无法做UI类的操作，因为程序已经运行不下去了，自测Toast会无效，但是log.d有用，文件读写是否有用有待测试)\r\n        Log.d(TAG, \"handleException: \" + ex.toString());\r\n        return true;\r\n    }\r\n\r\n}"
        },
        {
          "label": "NumberToRMB",
          "language": "java",
          "value": "import java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * 给金额字符串加上单位\r\n * <p>\r\n * 调用方式：\r\n * List<String> list = new NumberToRMB().getList( String );\r\n */\r\npublic class NumberToRMB {\r\n\r\n    private static final String CHINESE_UNIT = \"十亿千百十万千百十元\";\r\n\r\n    /**\r\n     * 返回符合要求的列表\r\n     *\r\n     * @return\r\n     */\r\n    public List<String> getList(String input) {\r\n        List<String> output = new ArrayList<>();\r\n        output.add(\"success\");\r\n        String integerStr, decimalStr;\r\n\r\n        //将整数部分装载到list中\r\n        integerStr = integerAddUnit(input.split(\"\\\\.\")[0]); //十亿01百万1千01十元\r\n        for (int i = 0, len = integerStr.length(); i < len; i++) {\r\n            char value = integerStr.charAt(i);\r\n            switch (value) {\r\n                case '元': //如果是元，得跳过，因为还有小数要装到list中，不能提前放元到list中\r\n                    break;\r\n                case '十':\r\n                    output.add(\"ten\");\r\n                    break;\r\n                case '百':\r\n                    output.add(\"hundred\");\r\n                    break;\r\n                case '千':\r\n                    output.add(\"thousand\");\r\n                    break;\r\n                case '万':\r\n                    output.add(\"ten_thousand\");\r\n                    break;\r\n                case '亿':\r\n                    output.add(\"hundred_million\");\r\n                    break;\r\n                default:\r\n                    output.add(String.valueOf(value));\r\n            }\r\n        }\r\n\r\n        //如果有小数点，将小数部分也装载到list中\r\n        if (input.contains(\".\")) {\r\n            output.add(\"dot\");\r\n            decimalStr = input.split(\"\\\\.\")[1];\r\n            output.add(String.valueOf(decimalStr.charAt(0)));\r\n            if (decimalStr.length() > 1) output.add(String.valueOf(decimalStr.charAt(1)));\r\n        }\r\n\r\n        output.add(\"yuan\");\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * 将小数点前的金额字符串加上单位\r\n     *\r\n     * @param str\r\n     * @return\r\n     */\r\n    private String integerAddUnit(String str) {\r\n        if (str == null || str.length() < 1) return \"0\";\r\n\r\n        //将值都简单的套上单位，例如: 2023000002 => \"2十0亿2千3百0十0万0千0百0十2元\"\r\n        StringBuilder temp = new StringBuilder();\r\n        for (int strIndex = str.length() - 1, unitIndex = CHINESE_UNIT.length() - 1;\r\n             strIndex >= 0;\r\n             unitIndex--, strIndex--) {\r\n            temp.append(CHINESE_UNIT.charAt(unitIndex));\r\n            temp.append(str.charAt(strIndex));\r\n        }\r\n        temp.reverse();\r\n\r\n        //对上一步的结果进行优化，省去不合理的单位，转换成日常读写的样子，例如：“2十0亿2千3百0十0万0千0百0十2元” => \"2十亿2千3百02元\"\r\n        String output = temp.toString();\r\n        for (int strLen = str.length(); strLen >= 0; ) {\r\n            if (strLen >= 9) { //数值大于亿\r\n                output = output.replace(\"0亿\", \"亿\"); // 将类似于 2十0亿 转换成 2十亿\r\n                strLen = 8;\r\n            } else if (strLen >= 5) { //数值大于万且小于亿\r\n                /*\r\n                 * 此处针对类似于：0千0百0十0万、1千0百0十0万、1千1百1十0万 进行优化，优化为 0、1万、1千1百1十万\r\n                 * 其中 0千0百0十0万 情况最为特殊，例如 200'001'000 为 2亿0千0百0十0万1千... 最终化简下来应是\r\n                 * 2亿01千元，如果 0千万 和0十万、0百万一样都替换成 万，则对于上面的例子则会替换成：2亿万1千元，单\r\n                 * 位将产生错误。\r\n                 */\r\n                output = output.replace(\"0万\", \"万\")\r\n                        .replace(\"0十万\", \"万\")\r\n                        .replace(\"0百万\", \"万\")\r\n                        .replace(\"0千万\", \"0\"); //0千万 要替换为 0 .这个很关键\r\n                strLen = 4;\r\n            } else if (strLen >= 2) { //数值十且小于万\r\n                output = output\r\n                        .replaceAll(\"0[十百千万]\", \"0\") //将 0十，0百 等相似情况都转换成 0\r\n                        .replaceAll(\"0+\", \"0\") //在上一步的基础上将 多个连续的零合并，只保留一个\r\n                        .replace(\"0元\", \"元\") //对 1十0元 等相似情况进行转换，转换成 1十元，注意：0元将不会被转换\r\n                        .replaceAll(\"^1十\", \"十\"); //将 1十亿元、1十万元、1十元 转换成 十亿元、十万元、十元\r\n                strLen = -1;\r\n            } else {\r\n                strLen = -1;\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n\r\n}\r\n"
        },
        {
          "label": "VoiceUtil",
          "language": "java",
          "value": "import android.content.Context;\r\nimport android.content.res.AssetFileDescriptor;\r\nimport android.content.res.AssetManager;\r\nimport android.media.MediaPlayer;\r\nimport android.media.PlaybackParams;\r\nimport android.os.Build;\r\n\r\nimport java.io.IOException;\r\nimport java.util.List;\r\nimport java.util.concurrent.CountDownLatch;\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\n\r\n/**\r\n * 音频播放类\r\n * <p>\r\n * 调用方式：\r\n * VoiceUtil.getInstance( Context ).play( List );\r\n */\r\npublic class VoiceUtil {\r\n\r\n    private static VoiceUtil mVoiceUtil = null;\r\n    private ExecutorService service; //线程池\r\n    private Context mContext;\r\n    private int count;\r\n\r\n    /**\r\n     * 创建单例\r\n     *\r\n     * @return\r\n     */\r\n    public static synchronized VoiceUtil getInstance(Context context) {\r\n        if (mVoiceUtil == null) {\r\n            mVoiceUtil = new VoiceUtil(context);\r\n        }\r\n        return mVoiceUtil;\r\n    }\r\n\r\n    /**\r\n     * 初始化\r\n     *\r\n     * @param context\r\n     */\r\n    private VoiceUtil(Context context) {\r\n        service = Executors.newCachedThreadPool();\r\n        this.mContext = context;\r\n    }\r\n\r\n    /**\r\n     * 播放前检查\r\n     *\r\n     * @param list\r\n     */\r\n    public void play(final List<String> list) {\r\n        if (service != null) { //如果线程池不等于空\r\n            service.execute(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    start(list); //list: [\"success\", \"1\", \"hundred\", \"yuan\"]\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 开始播放\r\n     *\r\n     * @param list 要播放的语音列表\r\n     */\r\n    private void start(final List<String> list) {\r\n        synchronized (this) {\r\n            final CountDownLatch latch = new CountDownLatch(1); //并发\r\n            MediaPlayer mediaPlayer = new MediaPlayer(); //安卓自带的播放类\r\n\r\n            if (list != null && list.size() > 0) {\r\n                //列表长度和标记位\r\n                final int listLen = list.size();\r\n                count = 0;\r\n                //装载第一个播放项\r\n                AssetManager manager = mContext.getAssets(); //可以读取assets文件中资源的类\r\n                AssetFileDescriptor fd = null;\r\n                try {\r\n                    String path = String.format(\"tts/tts_%s.mp3\", list.get(count));\r\n                    fd = manager.openFd(path);\r\n                    /*\r\n                     * setDataSource参数说明：\r\n                     * 第一个参数：FileDescriptor：您要播放的文件的FileDescriptor\r\n                     * 第二个参数：long：要播放的数据开始的文件的偏移量，以字节为单位\r\n                     * 第三个参数：long：要播放的数据的字节长度\r\n                     */\r\n                    mediaPlayer.setDataSource(fd.getFileDescriptor(), fd.getStartOffset(), fd.getLength());\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                    latch.countDown(); //发出当前线程的完成信号\r\n                } finally {\r\n                    if (fd != null) {\r\n                        try {\r\n                            fd.close(); //关闭文件\r\n                        } catch (IOException e) {\r\n                            e.printStackTrace();\r\n                        }\r\n                    }\r\n                }\r\n                mediaPlayer.prepareAsync(); //通过异步的方式加载\r\n\r\n                //开始播放\r\n                mediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {\r\n                    @Override\r\n                    public void onPrepared(MediaPlayer mediaPlayer) {\r\n                        mediaPlayer.start();\r\n                    }\r\n                });\r\n\r\n                //播放结束的回调\r\n                mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {\r\n                    @Override\r\n                    public void onCompletion(MediaPlayer mediaPlayer) {\r\n                        mediaPlayer.reset(); //重置播放状态\r\n                        count++;\r\n                        //加载下一个音频文件\r\n                        if (count < listLen) {\r\n                            AssetManager nextManager = mContext.getAssets();\r\n                            AssetFileDescriptor nextFd = null;\r\n                            try {\r\n                                String path = String.format(\"tts/tts_%s.mp3\", list.get(count));\r\n                                nextFd = nextManager.openFd(path);\r\n                                mediaPlayer.setDataSource(nextFd.getFileDescriptor(), nextFd.getStartOffset(), nextFd.getLength());\r\n                                mediaPlayer.prepare(); //以同步的方式加载\r\n                                //调整播放速度\r\n                                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) { //只有当前运行的版本大于6.0(VERSION_CODE=M)才运行此部分\r\n                                    PlaybackParams params = new PlaybackParams(); //调整播放参数的类，仅支持6.0及以上\r\n                                    params.setSpeed(1.2f); //播放速度最高支持到8.0f，即8倍速，其他参数还有控制音量\r\n                                    mediaPlayer.setPlaybackParams(params);\r\n                                }\r\n                            } catch (IOException e) {\r\n                                e.printStackTrace();\r\n                                latch.countDown(); //发出当前线程的完成信号\r\n                            } finally {\r\n                                if (nextFd != null) {\r\n                                    try {\r\n                                        nextFd.close(); //关闭文件\r\n                                    } catch (IOException e) {\r\n                                        e.printStackTrace();\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            mediaPlayer.release(); //回收流媒体资源\r\n                            latch.countDown(); //发出当前线程的完成信号\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            try {\r\n                latch.await(); //等待主线程执行完毕，获得开始执行信号\r\n                this.notifyAll();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n"
        },
        {
          "label": "SocketClient",
          "language": "java",
          "value": "import android.os.Handler;\r\nimport android.os.Looper;\r\nimport android.util.Log;\r\n\r\nimport java.io.DataOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\nimport java.net.ConnectException;\r\nimport java.net.InetSocketAddress;\r\nimport java.net.NoRouteToHostException;\r\nimport java.net.Socket;\r\nimport java.net.SocketTimeoutException;\r\nimport java.util.Arrays;\r\nimport java.util.Timer;\r\nimport java.util.TimerTask;\r\n\r\n/**\r\n * 一个socket client，设计成单例的形式，可进行收发消息，会定时向server端发送心跳包\r\n * <p>\r\n * <p>\r\n * 初始化SocketThread：<p>\r\n * SocketClient.INSTANCE.initSocket(ip, port)\r\n * <p>\r\n * <p>\r\n * 发送消息：<p>\r\n * SocketClient.INSTANCE.sendData(Msg)\r\n * <p>\r\n * <p>\r\n * 连接成功的回调：<p>\r\n * SocketClient.INSTANCE.setOnSocketStatusListener(() -> {...})\r\n * <p>\r\n * <p>\r\n * 接收到消息的回调：<p>\r\n * SocketClient.INSTANCE.setOnReceiveDataListener(message -> {...})\r\n */\r\n//TODO: 注意增加网络权限\r\npublic enum SocketClient {\r\n    INSTANCE; //通过枚举的方式创建单例\r\n    private static final String TAG = \"SocketClient\";\r\n\r\n    //字节流数据\r\n    public static final byte[] HEARTBEAT = {0x01, 0x00, 0x00, 0x00};\r\n    public static final byte[] BYTE_MSG_1 = {0x02, 0x00, 0x00, 0x00};\r\n    public static final byte[] BYTE_MSG_2 = {0x03, 0x00, 0x00, 0x00};\r\n\r\n    //字符流数据\r\n    //....\r\n\r\n    private String ip;\r\n    private int port;\r\n    private Socket socket;\r\n    private Thread connectThread;\r\n\r\n    private final int heartCycle = 10; //心跳周期(s)\r\n    private OutputStream outputStream; //发送输出流\r\n    private final boolean isReConnect = true; //默认重连\r\n    private Timer timer; //倒计时Timer发送心跳包\r\n    private TimerTask task;\r\n    private final Handler handler = new Handler(Looper.getMainLooper());\r\n\r\n\r\n    // ========================== callback =========================== //\r\n    public interface OnSocketStatusListener {\r\n        /**\r\n         * 连接成功的回调\r\n         */\r\n        void onConnectSuccess();\r\n    }\r\n\r\n    public interface OnReceiveDataListener {\r\n        /**\r\n         * 收到消息的回调\r\n         */\r\n        void onReceiveData(byte[] message);\r\n    }\r\n\r\n    public OnSocketStatusListener onSocketStatusListener;\r\n    public OnReceiveDataListener onReceiveDataListener;\r\n\r\n    public void setOnSocketStatusListener(OnSocketStatusListener onSocketStatusListener) {\r\n        this.onSocketStatusListener = onSocketStatusListener;\r\n    }\r\n\r\n    public void setOnReceiveDataListener(OnReceiveDataListener onReceiveDataListener) {\r\n        this.onReceiveDataListener = onReceiveDataListener;\r\n    }\r\n\r\n\r\n    // ========================== function =========================== //\r\n\r\n    /**\r\n     * 初始化socket\r\n     *\r\n     * @param ip   ip地址，如果使用回环地址，则应是127.0.0.1\r\n     * @param port 自定义通信端口，最大至65535\r\n     */\r\n    public void initSocket(final String ip, final int port) {\r\n        this.ip = ip;\r\n        this.port = port;\r\n\r\n        if (socket == null && connectThread == null) {\r\n            connectThread = new Thread(() -> {\r\n                socket = new Socket();\r\n                try {\r\n                    socket.connect(new InetSocketAddress(ip, port), 60_000); //超时时间为2秒\r\n                    if (socket.isConnected()) {\r\n                        Log.d(TAG, \"client:服务连接成功\");\r\n                        new ReadThread().start(); //开启读写线程\r\n                        if (onSocketStatusListener != null)\r\n                            onSocketStatusListener.onConnectSuccess(); //连接成功的回调\r\n                        Thread.sleep(5_000); //5s后发送心跳包\r\n                        sendHeartbeat();\r\n                    }\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                    if (e instanceof SocketTimeoutException) {\r\n                        Log.e(TAG, \"client:连接超时，正在重连\");\r\n                        releaseSocket();\r\n                    } else if (e instanceof NoRouteToHostException) {\r\n                        Log.e(TAG, \"client:该地址不存在，请检查\");\r\n                    } else if (e instanceof ConnectException) {\r\n                        Log.e(TAG, \"client:连接异常或被拒绝，请检查\");\r\n                    }\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            });\r\n            connectThread.start(); //启动连接线程\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 发送数据\r\n     *\r\n     * @param msg 一个byte数组\r\n     */\r\n    public void sendMessage(byte[] msg) {\r\n        if (socket != null && socket.isConnected()) {\r\n            /*发送指令*/\r\n            new Thread(() -> {\r\n                try {\r\n                    Log.i(TAG, \"client:发送自定义指令:\" + Arrays.toString(msg));\r\n                    //字节流\r\n                    DataOutputStream out = new DataOutputStream(socket.getOutputStream());\r\n                    out.write(msg);\r\n                    out.flush();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }).start();\r\n        } else {\r\n            Log.e(TAG, \"client:socket连接错误,请重试\");\r\n        }\r\n    }\r\n\r\n\r\n    // ========================== private function =========================== //\r\n\r\n    /**\r\n     * 读线程\r\n     */\r\n    private class ReadThread extends Thread {\r\n        @Override\r\n        public void run() {\r\n            super.run();\r\n            while (socket != null && socket.isConnected()) {\r\n                try (InputStream in = socket.getInputStream()) {\r\n                    //字节流\r\n                    byte[] buff = new byte[HEARTBEAT.length];\r\n                    while ((in.read(buff)) != -1) {\r\n                        Log.d(TAG, \"client:客户端收到的字节流: \" + Arrays.toString(buff));\r\n                        //接收到数据，切换主线程，显示数据\r\n                        handler.post(() -> {\r\n                            if (onReceiveDataListener != null) {\r\n                                onReceiveDataListener.onReceiveData(buff);\r\n                            }\r\n                        });\r\n                    }\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                    Log.e(TAG, \"client:接收总控数据异常\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 定时发送心跳数据\r\n     */\r\n    private void sendHeartbeat() {\r\n        if (timer == null) {\r\n            timer = new Timer();\r\n        }\r\n        if (task == null) {\r\n            task = new TimerTask() {\r\n                @Override\r\n                public void run() {\r\n                    try {\r\n                        Log.i(TAG, \"client:发送心跳包:\" + Arrays.toString(HEARTBEAT));\r\n                        //字节流\r\n                        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\r\n                        out.write(HEARTBEAT);\r\n                        out.flush();\r\n                    } catch (Exception e) {\r\n                        releaseSocket();\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        timer.schedule(task, 0, 1000 * heartCycle);\r\n    }\r\n\r\n    /**\r\n     * 释放资源\r\n     */\r\n    private void releaseSocket() {\r\n        if (task != null) {\r\n            task.cancel();\r\n            task = null;\r\n        }\r\n        if (timer != null) {\r\n            timer.purge();\r\n            timer.cancel();\r\n            timer = null;\r\n        }\r\n        if (outputStream != null) {\r\n            try {\r\n                outputStream.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            outputStream = null;\r\n        }\r\n        if (socket != null) {\r\n            try {\r\n                socket.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            socket = null;\r\n        }\r\n        if (connectThread != null) {\r\n            connectThread = null;\r\n        }\r\n        /*重新初始化socket*/\r\n        if (isReConnect) {\r\n            Log.e(TAG, \"client:连接断开，正在重连\");\r\n            initSocket(ip, port);\r\n        }\r\n    }\r\n\r\n}"
        },
        {
          "label": "SocketServer",
          "language": "java",
          "value": "import android.util.Log;\r\n\r\nimport java.io.DataOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.net.InetAddress;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 一个socket server，设计成单例的形式，可进行收发消息\r\n * <p>\r\n * <p>\r\n * 初始化SocketServer：<p>\r\n * SocketServer.INSTANCE.initSocketServer(port);\r\n * <p>\r\n * <p>\r\n * 发送消息：<p>\r\n * SocketServer.INSTANCE.sendMessage(Msg)\r\n */\r\n//TODO: 注意增加网络权限\r\npublic enum SocketServer {\r\n    INSTANCE; //通过枚举的方式创建单例\r\n    private static final String TAG = \"SocketServer\";\r\n\r\n    //字节流数据\r\n    public static final byte[] HEARTBEAT = {0x01, 0x00, 0x00, 0x00};\r\n    public static final byte[] BYTE_MSG_1 = {0x02, 0x00, 0x00, 0x00};\r\n    public static final byte[] BYTE_MSG_2 = {0x03, 0x00, 0x00, 0x00};\r\n\r\n    private Socket socket;\r\n\r\n\r\n    // ========================== function =========================== //\r\n\r\n    /**\r\n     * 初始化socketServer，监听端口，等待客户端连接\r\n     *\r\n     * @param port 自定义通信端口，最大至65535\r\n     */\r\n    public void initSocketServer(final int port) {\r\n        new Thread(() -> {\r\n            try {\r\n                ServerSocket serverSocket = new ServerSocket(port); //创建ServerSocket\r\n                Log.d(TAG, \"server:开启服务器\");\r\n                while (true) {\r\n                    Log.d(TAG, \"server:等待客户端连接\");\r\n                    socket = serverSocket.accept(); //等待客户端连接\r\n                    if (serverSocket.isBound()) {\r\n                        Log.d(TAG, \"server:得到客户端连接：\" + socket);\r\n                        new ReadThread().start(); //开启读写线程\r\n                    }\r\n                }\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }).start();\r\n    }\r\n\r\n\r\n    /**\r\n     * 通过socket来给客户端发送消息\r\n     *\r\n     * @param msg 字节数组\r\n     */\r\n    public void sendMessage(byte[] msg) {\r\n        if (socket != null) {\r\n            new Thread(() -> {\r\n                try {\r\n                    Log.i(TAG, \"server:发送自定义指令:\" + Arrays.toString(msg));\r\n                    //字节流\r\n                    DataOutputStream out = new DataOutputStream(socket.getOutputStream());\r\n                    out.write(msg);\r\n                    out.flush();\r\n                    //字符流\r\n//                    PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())), true);\r\n//                    out.println(msg);\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }).start();\r\n        } else {\r\n            Log.d(TAG, \"server:没有客户端连接，无法发送消息\");\r\n        }\r\n    }\r\n\r\n\r\n    // ========================== private function =========================== //\r\n\r\n    /**\r\n     * 读线程\r\n     */\r\n    private class ReadThread extends Thread {\r\n        @Override\r\n        public void run() {\r\n            super.run();\r\n            while (socket != null && socket.isConnected()) {\r\n                try (InputStream in = socket.getInputStream()) {\r\n                    //字节流\r\n                    byte[] buff = new byte[HEARTBEAT.length];\r\n                    while ((in.read(buff)) != -1) {\r\n                        Log.d(TAG, \"server:收到的字节流: \" + Arrays.toString(buff));\r\n                        //此处可增加回调...\r\n                    }\r\n                    //字符流\r\n//                    BufferedReader inBuff = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\r\n//                    String line;\r\n//                    while ((line = inBuff.readLine()) != null) {// 读取数据\r\n//                        Log.d(TAG, \"server:收到的字符流：\" + line);\r\n//                    }\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n"
        }
      ],
      "id": "wdwc3YPP",
      "createdAt": 1659359309378,
      "updatedAt": 1660917192232
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "1NX5tDl1",
      "tagsIds": [],
      "description": "在创建项目后常常会用到",
      "name": "基础类",
      "content": [
        {
          "label": "BaseFragment",
          "language": "java",
          "value": "import android.app.Activity;\r\nimport android.content.Context;\r\nimport android.os.Bundle;\r\nimport android.view.LayoutInflater;\r\nimport android.view.View;\r\nimport android.view.ViewGroup;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.annotation.Nullable;\r\nimport androidx.fragment.app.Fragment;\r\n\r\npublic abstract class BaseFragment extends Fragment {\r\n\r\n    protected Activity mActivity;\r\n    private TopButtonStateInterface topButtonStateInterface;\r\n\r\n    \r\n    /**\r\n     * 获得全局的，防止使用getActivity()为空\r\n     *\r\n     * @param context\r\n     */\r\n    @Override\r\n    public void onAttach(@NonNull Context context) {\r\n        super.onAttach(context);\r\n        this.mActivity = (Activity) context;\r\n\r\n        if (context instanceof TopButtonStateInterface) {\r\n            topButtonStateInterface = (TopButtonStateInterface) context;\r\n        } else {\r\n            throw new RuntimeException(context.toString() + \" must implement TopButtonStateInterface\");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container,\r\n                             Bundle savedInstanceState) {\r\n        View view = LayoutInflater.from(mActivity)\r\n                .inflate(getLayoutId(), container, false);\r\n        initView(view, savedInstanceState);\r\n\r\n        //通知activity显示顶部按钮\r\n        topButtonStateInterface.topButtonState();\r\n\r\n        return view;\r\n    }\r\n\r\n    @Override\r\n    public void onActivityCreated(@Nullable Bundle savedInstanceState) {\r\n        super.onActivityCreated(savedInstanceState);\r\n        initData();\r\n    }\r\n\r\n\r\n    /**\r\n     * 该抽象方法就是 onCreateView中需要的layoutID\r\n     *\r\n     * @return\r\n     */\r\n    protected abstract int getLayoutId();\r\n\r\n    /**\r\n     * 该抽象方法就是 初始化view\r\n     *\r\n     * @param view\r\n     * @param savedInstanceState\r\n     */\r\n    protected abstract void initView(View view, Bundle savedInstanceState);\r\n\r\n    /**\r\n     * 执行数据的加载\r\n     */\r\n    protected abstract void initData();\r\n\r\n    /**\r\n     * 顶部主页按钮和返回按钮的回调事件\r\n     * <p>\r\n     * （在activity中通过implements BaseFragment.TopButtonStateInterface使用）\r\n     */\r\n    public interface TopButtonStateInterface {\r\n        void topButtonState();\r\n    }\r\n}\r\n"
        },
        {
          "label": "mFragmentManage",
          "language": "java",
          "value": "import androidx.fragment.app.Fragment;\r\nimport androidx.fragment.app.FragmentActivity;\r\nimport androidx.fragment.app.FragmentManager;\r\nimport androidx.fragment.app.FragmentTransaction;\r\n\r\nimport com.example.androiddemoapp.R;\r\n\r\nimport java.util.List;\r\n\r\n/**\r\n * 控制Fragment增加、清除、替换等行为\r\n */\r\npublic class mFragmentManage {\r\n\r\n    private final FragmentActivity activity;\r\n    private final FragmentManager fragmentManager;\r\n\r\n    public mFragmentManage(FragmentActivity activity) {\r\n        this.activity = activity;\r\n        fragmentManager = activity.getSupportFragmentManager();\r\n    }\r\n\r\n    \r\n    /**\r\n     * 清空fragmentList的所有Fragment，替换成新的Fragment\r\n     *\r\n     * @param fragment\r\n     */\r\n    public void replaceFragment(Fragment fragment) {\r\n        FragmentManager fragmentManager = activity.getSupportFragmentManager();\r\n        FragmentTransaction transaction = fragmentManager.beginTransaction();\r\n        transaction.replace(R.id.main_fragment_frame, fragment);\r\n        transaction.commit();\r\n    }\r\n\r\n    /**\r\n     * 添加Fragment到FragmentList中\r\n     *\r\n     * @param fragment\r\n     */\r\n    public void addFragment(Fragment fragment) {\r\n        FragmentManager fragmentManager = activity.getSupportFragmentManager();\r\n        FragmentTransaction transaction = fragmentManager.beginTransaction();\r\n        transaction.add(R.id.main_fragment_frame, fragment);\r\n        transaction.commit();\r\n    }\r\n\r\n    /**\r\n     * 移除最上层的Fragment\r\n     */\r\n    public int removeFragment() {\r\n        List<Fragment> fragments = fragmentManager.getFragments();\r\n        if ((fragments != null) && (fragments.size() > 1)) { //当fragment栈有多个fragment时，返回函数才会生效\r\n            FragmentTransaction transaction = fragmentManager.beginTransaction();\r\n            transaction.remove(fragments.get(fragments.size() - 1));\r\n            transaction.commit();\r\n            return fragmentManager.getFragments().size() - 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n}\r\n"
        },
        {
          "label": "CommonBaseAdapter",
          "language": "java",
          "value": "import android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport androidx.annotation.NonNull;\nimport androidx.recyclerview.widget.RecyclerView;\n\nimport java.util.List;\n\n/**\n * 通用RecyclerView适配器\n * <p>\n * 1. 在新的类中直接实现其中的接口即可使用：implements CommonBaseAdapter...\n * 2. 使用匿名内部类的形式创建：CommonBaseAdapter<mType> Adapter = new CommonBaseAdapter<>(list, new CommonBaseAdapter.OnBindDataInterface<mType>() {...}\n */\npublic class CommonBaseAdapter<T> extends RecyclerView.Adapter<BaseViewHolder> {\n\n    private final List<T> mData;\n    private final OnBindDataInterface<T> mOnBindDataInterface;\n    private OnMultiTypeBindDataInterface<T> mOnMultiTypeBindDataInterface;\n    private ItemOnClickInterface itemOnClickInterface;\n\n\n    //单样式列表初始化方法\n    public CommonBaseAdapter(List<T> data, OnBindDataInterface<T> bindInterface) {\n        mData = data;\n        mOnBindDataInterface = bindInterface;\n    }\n\n    //多样式列表初始化方法\n    public CommonBaseAdapter(List<T> data, OnMultiTypeBindDataInterface<T> bindInterface) {\n        mData = data;\n        mOnMultiTypeBindDataInterface = bindInterface;\n        mOnBindDataInterface = bindInterface;\n    }\n\n    //itemOnClickInterface初始化\n    public void setItemOnClickInterface(ItemOnClickInterface itemOnClickInterface) {\n        this.itemOnClickInterface = itemOnClickInterface;\n    }\n\n\n    @NonNull\n    @Override\n    public BaseViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        View view = LayoutInflater\n                .from(parent.getContext())\n                .inflate(mOnBindDataInterface.getItemLayoutId(viewType), parent, false);\n        return new BaseViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(@NonNull BaseViewHolder holder, int position) {\n        mOnBindDataInterface.onBindData(mData.get(position), holder, getItemViewType(position),\n                itemOnClickInterface);\n    }\n\n    @Override\n    public int getItemCount() {\n        return this.mData.size();\n    }\n\n    @Override\n    public int getItemViewType(int position) {\n        if (mOnMultiTypeBindDataInterface != null) {\n            return mOnMultiTypeBindDataInterface.getItemViewType(position);\n        }\n        return 0;\n    }\n\n\n    //单样式item绑定数据的接口，包含一个 布局绑定函数 和 布局中控件的绑定函数\n    public interface OnBindDataInterface<T> {\n        /**\n         * 绑定列表元素的item页面(R.layout.xxx)\n         *\n         * @param viewType\n         * @return\n         */\n        int getItemLayoutId(int viewType);\n\n        /**\n         * 绑定数据(R.id.xxx)，最后一个type参数是多类型item使用的\n         *\n         * @param item   item.get()\n         * @param holder holder.setText(R.id.xxx, \"a string\")\n         * @param type   default 0\n         */\n        void onBindData(T item, BaseViewHolder holder, int type, ItemOnClickInterface itemOnClickInterface);\n    }\n\n    // 多类型item的支持，例如包含head的列表\n    public interface OnMultiTypeBindDataInterface<T> extends OnBindDataInterface<T> {\n        /**\n         * 返回item类型，针对不同的item类型使用不同的布局元素\n         *\n         * @param position switch(case 0, case 1, case 2...)\n         * @return\n         */\n        int getItemViewType(int position);\n    }\n\n    // item的回调接口，当item被点击时，能在其他类中获得相关内容并修改item\n    public interface ItemOnClickInterface {\n        /**\n         * @param position 被点击的item下标\n         */\n        void onItemClick(int position);\n    }\n\n}"
        },
        {
          "label": "BaseViewHolder",
          "language": "java",
          "value": "import android.util.SparseArray;\r\nimport android.view.View;\r\nimport android.widget.ImageView;\r\nimport android.widget.TextView;\r\n\r\nimport androidx.recyclerview.widget.RecyclerView;\r\n\r\nimport com.bumptech.glide.Glide;\r\n\r\n/**\r\n * 通用的ViewHolder，与CommonBaseAdapter配套使用\r\n */\r\npublic class BaseViewHolder extends RecyclerView.ViewHolder {\r\n\r\n    private final SparseArray<View> mViews;\r\n\r\n    public BaseViewHolder(View itemView) {\r\n        super(itemView);\r\n        mViews = new SparseArray<>();\r\n    }\r\n\r\n    /**\r\n     * 通过viewId获取控件\r\n     *\r\n     * @param viewId R.id.xxx\r\n     * @return\r\n     */\r\n    public <T extends View> T getSubView(int viewId) {\r\n        View view = mViews.get(viewId);\r\n        if (view == null) {\r\n            view = itemView.findViewById(viewId);\r\n            mViews.put(viewId, view);\r\n        }\r\n        return (T) view;\r\n    }\r\n\r\n    /**\r\n     * 点击事件\r\n     *\r\n     * @param viewId   R.id.xxx\r\n     * @param listener\r\n     */\r\n    public void setOnClickListener(int viewId, View.OnClickListener listener) {\r\n        View view = getSubView(viewId);\r\n        view.setOnClickListener(listener);\r\n    }\r\n\r\n    /**\r\n     * 设置TextView内容\r\n     *\r\n     * @param viewId R.id.xxx\r\n     * @param text   a string\r\n     */\r\n    public void setText(int viewId, String text) {\r\n        TextView tv = getSubView(viewId);\r\n        if (tv != null) {\r\n            tv.setText(text);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 设置ImageView背景图片\r\n     *\r\n     * @param viewId R.id.xxx\r\n     * @param resId  R.drawable.xxx\r\n     */\r\n    public void setImage(int viewId, int resId) {\r\n        ImageView iv = getSubView(viewId);\r\n        if (iv != null) {\r\n            iv.setBackgroundResource(resId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 设置ImageView大尺寸图片\r\n     *\r\n     * @param viewId R.id.xxx\r\n     * @param resId  R.drawable.xxx\r\n     */\r\n    public void setBigImage(int viewId, int resId) {\r\n        ImageView iv = getSubView(viewId);\r\n        if (iv != null) {\r\n            Glide.with(iv.getContext()).load(resId).into(iv);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 设置网络资源图片\r\n     *\r\n     * @param viewId R.id.xxx\r\n     * @param resUrl http:\\\\....\\\r\n     */\r\n\tpublic void setNetworkImage(int viewId, String resUrl) {\r\n        ImageView iv = getSubView(viewId);\r\n        if (iv != null) {\r\n//            RequestOptions options = new RequestOptions()\r\n//                    .placeholder(R.drawable.xxx) //加载之前显示的图片\r\n//                    .fallback(R.drawable.xxx) //url为空显示的图片\r\n//                    .error(R.drawable.xxx); //加载失败显示的图片\r\n//            Glide.with(iv.getContext())\r\n//\t\t\t\t\t  .load(resUrl)\r\n//                    .centerInside() //对齐方式\r\n//\t\t\t\t\t  .override(width, height) //图片长宽\r\n//\t\t\t\t\t  .apply(options)\r\n//\t\t\t\t\t  .into(iv);\r\n        }\r\n    }\r\n\r\n}\r\n"
        }
      ],
      "id": "AUStwG-e",
      "createdAt": 1659359351474,
      "updatedAt": 1659668249597
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "1NX5tDl1",
      "tagsIds": [],
      "description": "以少量函数的形式存在，可方便实现单一功能",
      "name": "片段",
      "content": [
        {
          "label": "ReadAssetsFile",
          "language": "java",
          "value": "/**\r\n * 获取assets文件中的数据\r\n * <p>\r\n * @param context  getContext()\r\n * @param fileName \"xxx.json\"\r\n * @return String\r\n */\r\npublic static String ReadAssetsFile(Context context, String fileName) {\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    try {\r\n        AssetManager assetManager = context.getAssets();\r\n        BufferedReader bf = new BufferedReader(\r\n                new InputStreamReader(assetManager.open(fileName)));\r\n        String line;\r\n        while ((line = bf.readLine()) != null) {\r\n            stringBuilder.append(line);\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n    return stringBuilder.toString();\r\n}\r\n"
        },
        {
          "label": "setStatusBarMode",
          "language": "java",
          "value": "/**\r\n * 将状态栏设置成自定义文字和背景\r\n * 此效果只对Android 6.0以上有效果\r\n * <p>\r\n * 调用方式：\r\n * setLightMode(getWindow(), R.color.xxx, true);\r\n * <p>\r\n * @param win      当前页面窗口\r\n * @param colorId  颜色id\r\n * @param darkText 是否使用深色图标和字体\r\n */\r\npublic static void setStatusBarMode(Window win, int colorId, boolean darkText) {\r\n    // 设置状态栏底色\r\n    win.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\r\n    win.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);\r\n    win.setStatusBarColor(ContextCompat.getColor(win.getContext(), colorId));\r\n\r\n    // 设置状态栏字体是否为黑色\r\n    if (darkText) {\r\n        win.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);\r\n    } else {\r\n        win.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_VISIBLE);\r\n    }\r\n}"
        },
        {
          "label": "ToastUtil",
          "language": "java",
          "value": "import android.content.Context;\r\nimport android.widget.Toast;\r\n\r\n/**\r\n * 防止Toast被多次点击\r\n * <p>\r\n * 调用方式：\r\n * ToastUtil.showShortToast( Context , String );\r\n */\r\npublic class ToastUtil {\r\n\r\n    private static Toast toast;\r\n\r\n    /**\r\n     * 显示短时间的Toast\r\n     *\r\n     * @param context this\r\n     * @param content 消息提醒的内容\r\n     */\r\n    public static void showShortToast(Context context, String content) {\r\n        if (toast == null) {\r\n            toast = Toast.makeText(context, content, Toast.LENGTH_SHORT);\r\n        } else {\r\n            toast.setText(content);\r\n        }\r\n        toast.show();\r\n    }\r\n\r\n    /**\r\n     * 显示长时间的Toast\r\n     *\r\n     * @param context this\r\n     * @param content 消息提醒的内容\r\n     */\r\n    public static void showLongToast(Context context, String content) {\r\n        if (toast == null) {\r\n            toast = Toast.makeText(context, content, Toast.LENGTH_LONG);\r\n        } else {\r\n            toast.setText(content);\r\n        }\r\n        toast.show();\r\n    }\r\n}\r\n"
        },
        {
          "label": "showActivityToMultipleScreen",
          "language": "java",
          "value": "/**\r\n * 在扩展屏中创建一个新页面（双屏异显）\r\n *\r\n * @param mContext  activity or application context\r\n * @param mActivity [Jump_Activity_Name].class\r\n * @param <T>       a class type\r\n */\r\n<T> void showActivityToMultipleScreen(Context mContext, Class<T> mActivity) {\r\n    DisplayManager displayManager = (DisplayManager) getSystemService(Context.DISPLAY_SERVICE);\r\n    Display[] displays = displayManager.getDisplays(); //获取所有屏幕\r\n    \r\n    if (displays.length > 1 && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n        Intent intent = new Intent(mContext, mActivity);\r\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_MULTIPLE_TASK);\r\n        ActivityOptions options = ActivityOptions.makeBasic();\r\n        options.setLaunchDisplayId(displays[1].getDisplayId()); //setLaunchDisplayId需要在android 8.0及以上使用\r\n        startActivity(intent, options.toBundle());\r\n    }\r\n}"
        }
      ],
      "id": "HsJpzGes",
      "createdAt": 1659367449128,
      "updatedAt": 1661011554867
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "1NX5tDl1",
      "tagsIds": [],
      "description": "自定义UI控件的代码，包括java或者xml文件",
      "name": "自定义控件",
      "content": [
        {
          "label": "VerticalSeekBar",
          "language": "java",
          "value": "import android.content.Context;\r\nimport android.graphics.Canvas;\r\nimport android.util.AttributeSet;\r\nimport android.view.MotionEvent;\r\n\r\n/**\r\n * 竖直的seekbar，xml文件中直接使用此自定义控件\r\n */\r\npublic class VerticalSeekBar extends androidx.appcompat.widget.AppCompatSeekBar {\r\n    private OnSeekBarChangeListener mOnSeekBarChangeListener;\r\n\r\n    public VerticalSeekBar(Context context) {\r\n        super(context);\r\n    }\r\n\r\n    public VerticalSeekBar(Context context, AttributeSet attrs) {\r\n        super(context, attrs);\r\n    }\r\n\r\n    public VerticalSeekBar(Context context, AttributeSet attrs, int defStyleAttr) {\r\n        super(context, attrs, defStyleAttr);\r\n    }\r\n\r\n    public void setOnSeekBarChangeListener(OnSeekBarChangeListener l) {\r\n        mOnSeekBarChangeListener = l;\r\n    }\r\n\r\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\r\n        super.onSizeChanged(h, w, oldh, oldw);\r\n    }\r\n\r\n    @Override\r\n    protected synchronized void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\r\n        super.onMeasure(heightMeasureSpec, widthMeasureSpec);\r\n        setMeasuredDimension(getMeasuredHeight(), getMeasuredWidth());\r\n    }\r\n\r\n    protected void onDraw(Canvas c) {\r\n        c.rotate(-90); //旋转画布，实现竖直seekbar\r\n        c.translate(-getHeight(), 0);\r\n        super.onDraw(c);\r\n    }\r\n\r\n    void onProgressChanged(int progress) {\r\n        if (mOnSeekBarChangeListener != null) {\r\n            mOnSeekBarChangeListener.onProgressChanged(this, progress, true);\r\n        }\r\n    }\r\n\r\n    void onStartTrackingTouch() {\r\n        if (mOnSeekBarChangeListener != null) {\r\n            mOnSeekBarChangeListener.onStartTrackingTouch(this);\r\n        }\r\n    }\r\n\r\n    void onStopTrackingTouch() {\r\n        if (mOnSeekBarChangeListener != null) {\r\n            mOnSeekBarChangeListener.onStopTrackingTouch(this);\r\n        }\r\n    }\r\n\r\n    private void attemptClaimDrag() {\r\n        if (getParent() != null) {\r\n            getParent().requestDisallowInterceptTouchEvent(true);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean onTouchEvent(MotionEvent event) {\r\n        if (!isEnabled()) {\r\n            return false;\r\n        }\r\n        switch (event.getAction()) {\r\n            case MotionEvent.ACTION_DOWN:\r\n                setPressed(true);\r\n                onStartTrackingTouch();\r\n                break;\r\n            case MotionEvent.ACTION_MOVE:\r\n                attemptClaimDrag();\r\n                int len = getMax() - getMin();\r\n                int num = (getMax() - (int) (len * event.getY() / getHeight())); //根据触摸调整进度条\r\n                num = (num > getMax()) ? getMax() : num; //num的值最大为getMax()\r\n                num = (num < getMin()) ? getMin() : num; //num的值最小为getMin()\r\n                setProgress(num);\r\n                onProgressChanged(num);\r\n                break;\r\n            case MotionEvent.ACTION_UP:\r\n            case MotionEvent.ACTION_CANCEL:\r\n                onStopTrackingTouch();\r\n                setPressed(false);\r\n                break;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"
        }
      ],
      "id": "BszPKY2C",
      "createdAt": 1659367456523,
      "updatedAt": 1659668129778
    }
  ],
  "tags": []
}